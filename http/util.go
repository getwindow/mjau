// Copyright (c) 2012, Robert Dinu. All rights reserved.
// Use of this source code is governed by a BSD-style
// license which can be found in the LICENSE file.

package http

import (
	"bytes"
	"compress/gzip"
	"net/http"
	"strings"
)

type gzipResponseWriter struct {
	buf bytes.Buffer
	http.ResponseWriter
}

func (w *gzipResponseWriter) Write(b []byte) (int, error) {
	return w.buf.Write(b)
}

// BadRequest sends an HTTP response header
// with 400 bad request status code.
func BadRequest(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusBadRequest)
}

// Forbidden sends an HTTP response header
// with 403 forbidden status code.
func Forbidden(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusForbidden)
}

// InternalServerError sends an HTTP response header
// with 500 internal server error status code.
func InternalServerError(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusInternalServerError)
}

// MakeGzipHandler is a http handler wrapper which applies gzip compression
// to the response body generated by the wrapped http handler.
func MakeGzipHandler(fn http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		acceptEncoding := r.Header.Get("Accept-Encoding")
		if !strings.Contains(acceptEncoding, "gzip") {
			fn(w, r)
			return
		}
		w.Header().Set("Content-Encoding", "gzip")
		gw := &gzipResponseWriter{ResponseWriter: w}
		fn(gw, r)
		gzipWriter := gzip.NewWriter(w)
		defer gzipWriter.Close()
		gw.buf.WriteTo(gzipWriter)
	}
}

// NotImplemented sends an HTTP response header
// with 501 not implemented status code.
func NotImplemented(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// NotModified sends an HTTP response header
// with 304 not modified status code.
func NotModified(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotModified)
}
